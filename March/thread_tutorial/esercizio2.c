/* 
     Scrivere un programma in C che all'avvio crei 3 thread.
        I thread 0 e 1 compiono ciascuno le seguenti azioni:
        - per 20 volte:
            a) acquisiscono la mutua esclusione su una variabile intera condivisa 'count' (inizializzata a 0);
            b) incrementano count;
            c) stampano a video il proprio indice e il nuovo valore di count;
            d) rilasciano la mutua esclusione.
        Il thread 2 compie le seguenti azioni:
        - verifica se count ha valore pari a 5:
            a) se la condizione è falsa, il thread si sospende;
            b) se la condizione è vera, stampa il proprio id e il messaggio "Threshold reached", poi termina;
            c) rilascia la mutua esclusione.
        Utilizzare le variabili condition.


        1.)POSIX thread IDs are assigned and maintained by the threading implementation. 
        The thread ID returned by gettid() is a number (similar to a process ID) that is assigned by the kernel.

        2.)ID generated by the pthread_self() can be used after the completion of the thread but  
        the ID genereated by the kernel can't be used even after the completion of the thread..
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdbool.h>
#include <unistd.h>


#define THREAD_CYCLES 20
#define THREAD_NUM 3

// shared variable
int count = 0;
// mutex
pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
// condition variable
pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
// used to terminate the controller thread
bool stop = false;

void *increment(void *args)
{
    for (int i = 0; i < THREAD_CYCLES; ++i)
    {
        // acquire mutex to increment the count variable
        pthread_mutex_lock(&mu);
        count++;
        printf("[%d] Thread - count: %d\n", gettid(), count);
        if (count == 5)
        {  
            stop = true;
            // send signal to the waiting thread
            pthread_cond_signal(&cv);
        }
        // release mutex
        pthread_mutex_unlock(&mu);
        sleep(1);

        if (stop)
        {
            break;
        }
    }
    // pthread_exit(NULL);
}

void *checkThreshold(void *args)
{
    // acquire mutex and check for conditions to be satisfied
    pthread_mutex_lock(&mu);
    while (count < 5)
    { 
        pthread_cond_wait(&cv, &mu);
    }

    printf("[%d] Thread - Threshold reached\n", gettid());
    pthread_mutex_unlock(&mu);

    pthread_exit(NULL);
}


int main(int args, char **argv)
{
    
    // thread creation
    pthread_t th[THREAD_NUM];
    pthread_create(&th[0], NULL, &increment, NULL);
    pthread_create(&th[1], NULL, &increment, NULL);
    pthread_create(&th[2], NULL, &checkThreshold, NULL);

    for (int i = 0; i < THREAD_NUM - 1; ++i)
    {
        pthread_join(th[i], NULL);
    }

    pthread_mutex_destroy(&mu);
    pthread_cond_destroy(&cv);
    return 0;
}



